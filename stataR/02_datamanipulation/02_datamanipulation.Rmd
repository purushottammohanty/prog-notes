---
title: "Introduction to R for Stata Users"
author: "Purushottam Mohanty"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  xaringan::moon_reader:
    css:
    - default
    - metropolis
    - metropolis-fonts
    nature:
      highlightStyle: github
      highlightLines: yes
      countIncrementalSlides: no
  pdf_document: default
subtitle: '02: Data Manipulation'
---

```{css, echo=FALSE}
# CSS for including pauses in printed PDF output (see bottom of lecture)
@media print {
  .has-continuation {
    display: block !important;
  }
}

.code-bg-stata .remark-code, .code-bg-stata .remark-code * {
 background-color:Silver!important;
}

```


```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
library(knitr)
opts_chunk$set(
  fig.align="center",  
  fig.height=4, #fig.width=6,
  # out.width="748px", #out.length="520.75px",
  dpi=300, #fig.path='Figs/',
  cache=T#, echo=F, warning=F, message=F
  )
library(tidyverse)
library(pagedown)
```

# overview

Data manipulation or data cleaning is an important aspect of any project and it is important to be well acquainted with all the tools provided by R to facilitate an easy transition from Stata to R.   
    
While Stata has specific commands for specific data cleaning operations, R is more versatile and often the same operation can be performed in multiple ways through different packages.           
      
In this slide deck I use `dplyr` and `tidyr` packages to perform data manipulation operations. The same tasks can also be performed using `baseR` functions but they are often more complicated and cumbersome.    
    
I also provide equivalent commands in Stata where possible to help easily understand R functions.

---

# tidyverse

The `tidyverse` package in R is a composite of many different data manipulation, functional programming and data visualization packages. Check documentation about [tidyverse](https://www.tidyverse.org/packages/), [dplyr](https://dplyr.tidyverse.org) and [tidyr](https://tidyr.tidyverse.org) for more information.

```{r}
# only loads the primary tidyverse packages 
library(tidyverse) 
tidyverse_packages()
```

Packages like `ggplot2` for data visualization, `forcats` for handling categorical data and `stringr` for text manipulation enable so many possibilities. Packages within tidyverse can be separately loaded as well.

---

# pipe %>% operator

Many different packages in R, including `tidyr` and `dplyr` follow the pipe `%>%` operator syntax which makes way for clean looking code and saves considerable time by not having to specify the dataframe name everytime.

```{r, echo=F}
df = gapminder::gapminder
```

```{r, eval=F}
# both lines are equivalent
df %>% filter(!continent == 'Europe') %>% group_by(continent, year) %>% 
  summarize(mean_gdppc = mean(gdpPercap))
summarise(group_by(filter(df, !continent == 'Europe'), continent, year), mean_gdppc = mean(gdpPercap))
```

The first line can be read as, specifying the dataframe, filtering the rows and then grouping based on column names and the summarizing the gdpPercap variable. As you can see the first line is easier to read and logical in nature. With complicated and lengthy code, `%>%` operator becomes extremely handy.

---

class: inverse, center, middle
name: dplyr

# dplyr

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---


# create new columns (1/n)

In R, new columns can be created using `dplyr::mutate()` function.
```{r, eval=F}
df %>% 
  mutate(pop_mn = pop / 1000000)
```

Note that `mutate()` creates a new column if dataframe `df` doesn't have a column with the specified namespace (i.e. `pop_mn`) or overwrites the existing column. So, `mutate()` is a substitute for Stata commands `generate` and `replace` depending on the namespace provided.  

.code-bg-stata[
```{r, eval=F}
# Stata equivalent
generate pop_mn = pop / 1000000
replace pop_mn = pop / 1000000
```
]

---
# create new column (2/n)

The original dataframe imported from the `gapminder` package.
```{r, eval=T}
df 
```


---
# create new column (3/n)

New column `pop_mn` has been created.
```{r, eval=T}
df %>% 
  mutate(pop_mn = pop / 1000000)
```

---
# create new column (4/n)

Let's overwite `pop_mn` where `pop_mn` is log of population. Note how the old `pop_mn` column is overwritten with log population values. Also, see how the `%>%` function allows us to perform multiple operations on the same dataframe.
```{r, eval=T}
df %>% 
  mutate(pop_mn = pop / 1000000) %>%
  mutate(pop_mn = log(pop))
```

---

# filter rows (1/n)

In R rows can be filtered using `dplyr::filter()` function.
```{r, eval=F}
df %>% 
  filter(continent == "Europe")
```
This keeps only those rows for which continent is Europe. Similarly, for keeping all rows outside continent Europe one can use the "!=" logical operation. Multiple conditions can also be specified using,
```{r, eval=F}
df %>% 
  filter(continent %in% c("Europe", "Africa"))
df %>% 
  filter(continent == "Europe" | continent == "Africa")
```
Both lines above are equivalent. Note how the `%in%` syntax makes code much more concise and readable.

.code-bg-stata[
```{r, eval=F}
# Stata equivalent
keep if continent == "Europe"
keep if continent == "Europe" | continent == "Africa"
```
]

---
# filter rows (2/n)

Only keeps the rows where continent is Europe.
```{r, eval=T}
df %>% 
  filter(continent == "Europe")
```

---
# filter rows (3/n)

Keeps all rows where continent is either Europe or Africa. (check no. of rows)
```{r, eval=T}
df %>% 
  filter(continent %in% c("Africa", "Europe"))
```


---

# filter columns (1/n)

In R, columns can be filtered using the `dplyr::select()` function. 
```{r, eval=F}
df %>% 
  select(continent)
df %>%
  select(country, continent)
```

Similarly, columns can be dropped using a `-` sign before the column name 
```{r, eval=F}
df %>% 
  select(-country, -continent)
```

Unlike Stata, for R both keeping and dropping columns is done using the same function. Also, one can use `select()` to order columns with or without dropping columns using the `select(columnA, columnB, everything())` syntax. The `everything()` function selects all columns not specified in `select()`.

.code-bg-stata[
```{r, eval=F}
# Stata equivalent
keep country continent 
drop country continent
```
]

---
# filter columns (2/n)
```{r, eval=T}
df %>% 
  dplyr::select(continent, country)
```

---
# filter columns (3/n)
```{r, eval=T}
df %>% 
  dplyr::select(-continent, -country)
```


---
# order rows (1/n)

In R, rows can be ordered is ascending or descending order using the `dplyr::arrange()` function.
```{r, eval=F}
df %>% 
  arrange(year, gdpPercap) # ascending order
df %>%
  arrange(desc(year), desc(gdpPercap)) # descending order
```

.code-bg-stata[
```{r, eval=F}
# Stata equivalent
sort year gdpPercap
gsort -year -gdpPercap # using gtools
```
]

---
# order rows (2/n)

```{r, eval=T}
df %>% 
  arrange(year, gdpPercap) # ascending order
```

---
# order rows (3/n)

```{r, eval=T}
df %>%
  arrange(desc(year), desc(gdpPercap)) # descending order
```

---
# distinct (1/n)

In R, duplicates can be removed from a dataframe using `dplyr::distinct()` function. The `.keep_all = T` option ensures that all columns are kept after removal of the duplicates.
```{r, eval=F}
df %>% 
  distinct(.keep_all = T)
```

Duplicates can also be removed from a particular column using,
```{r, eval=F}
df %>% 
  distinct(country, .keep_all = T)
```

The `distinct()` can also be used to view unique values for a column(s).
```{r, eval=F}
df %>% 
  distinct(country) # all countries present in df
```

.code-bg-stata[
```{r, eval=F}
# Stata equivalent
duplicates drop # for all rows
duplicates drop country, force # for a column
duplicates report country
```
]

---
# distinct (2/n)
```{r, eval=T}
df %>% 
  distinct(.keep_all = T)
```

---
# distinct (3/n)
```{r, eval=T}
df %>% 
  distinct(country, .keep_all = T)
```

---
# distinct (4/n)
```{r, eval=T}
df %>% 
  distinct(country) 
```

---
# summarize (1/n)

Summarize operates with `mutate()` at the backend and creates a new dataframe with specified columns based on the statistics specified. Note that `summarize()` and `summarise()` are equivalent to each other and can be interchanged. 
```{r, eval=F}
df %>% 
  summarize(mean_pop = mean(pop), median_gdppc = median(gdpPercap))
```

Summarise can be performed across multiple columns in combination with the `across()` function.
```{r, eval=F}
df %>% 
  summarize(across(c("pop","gdpPercap"), mean))
```

.code-bg-stata[
```{r, eval=F}
# Stata equivalent
collapse (mean) pop (median) gdpPercap
```
]

---
# summarize (2/n)

```{r, eval=T}
df %>% 
  summarize(mean_pop = mean(pop), median_gdppc = median(gdpPercap))
```

```{r, eval=T}
df %>% 
  summarize(across(c("pop","gdpPercap"), mean))
```


---
# group operations


---
# reshape - long to wide


---
# reshape (cont.) - wide to long


---
# merging columns


---
# merging rows

---

class: inverse, center, middle
name: data.table

# data.table

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---



```{r gen_pdf, include = FALSE, cache = FALSE, eval = FALSE}
pagedown::chrome_print("01_datamanipulation.html", output = "01_datamanipulation.pdf")
```






